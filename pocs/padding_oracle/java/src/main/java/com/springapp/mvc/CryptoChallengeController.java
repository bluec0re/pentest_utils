package com.springapp.mvc;

import org.apache.commons.codec.binary.Base64;
import org.json.JSONException;
import org.json.JSONObject;
import org.springframework.stereotype.Controller;
import org.springframework.ui.ModelMap;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.util.Arrays;

@Controller
//@RequestMapping(value = "/crypto")
public class CryptoChallengeController {
    private static final String CRYPTO_KEY = "Sup3r s3cr3t K3y!!??";
    private static final byte[] CRYPTO_IV = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    private static final String TOKEN = "119d7457-bfa0-4b0d-a1f0-a70e00bf422e";

    @RequestMapping(method = RequestMethod.GET)
    public String listChallenges() {
        return "crypto/list";
    }

    public byte[] encryptCBC(byte[] data) throws GeneralSecurityException {
        byte[] key = CRYPTO_KEY.getBytes();
        MessageDigest sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");

        IvParameterSpec ivspec = new IvParameterSpec(CRYPTO_IV);
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);

        return cipher.doFinal(data);
    }

    public byte[] decryptCBC(byte[] data) throws GeneralSecurityException {
        byte[] key = CRYPTO_KEY.getBytes();
        MessageDigest sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");

        IvParameterSpec ivspec = new IvParameterSpec(CRYPTO_IV);
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);

        return cipher.doFinal(data);
    }

    public byte[] encryptEBC(byte[] data) throws GeneralSecurityException {
        byte[] key = CRYPTO_KEY.getBytes();
        MessageDigest sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");

        IvParameterSpec ivspec = new IvParameterSpec(CRYPTO_IV);
        Cipher cipher = Cipher.getInstance("AES/EBC/PKCS5Padding");
        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, ivspec);

        return cipher.doFinal(data);
    }

    public byte[] decryptEBC(byte[] data) throws GeneralSecurityException {
        byte[] key = CRYPTO_KEY.getBytes();
        MessageDigest sha = MessageDigest.getInstance("SHA-1");
        key = sha.digest(key);
        key = Arrays.copyOf(key, 16);
        SecretKeySpec skeySpec = new SecretKeySpec(key, "AES");

        IvParameterSpec ivspec = new IvParameterSpec(CRYPTO_IV);
        Cipher cipher = Cipher.getInstance("AES/EBC/PKCS5Padding");
        cipher.init(Cipher.DECRYPT_MODE, skeySpec, ivspec);

        return cipher.doFinal(data);
    }

    private JSONObject cryptoChallengeDecrypt(ChallengeMode mode, String settingsCookie) throws IOException, GeneralSecurityException, JSONException {
        if(settingsCookie == null || settingsCookie.equals("notset")) {
            return null;
        }

        byte[] data = Base64.decodeBase64(settingsCookie.getBytes());

        byte[] result = null;
        switch (mode) {
            case CBC: {
                result = decryptCBC(data);
            } break;
            case EBC: {
                result = decryptEBC(data);
            } break;
        }

        String json = new String(result);

        return new JSONObject(json);
    }

    private String cryptoChallengeEncrypt(ChallengeMode mode, String data) throws IOException, GeneralSecurityException {


        byte[] result = null;
        switch (mode) {
            case CBC: {
                result = encryptCBC(data.getBytes());
            } break;
            case EBC: {
                result = encryptEBC(data.getBytes());
            } break;
        }

        byte[] b64 = Base64.encodeBase64(result);
        return new String(b64);
    }

    @RequestMapping(value = "/", method = RequestMethod.GET)
    public String cbcChallenge(@CookieValue(value = "settings", defaultValue = "notset") String settingsCookie, ModelMap model) throws IOException, GeneralSecurityException, JSONException {

        if(!settingsCookie.equals("notset"))
            model.addAttribute("name", cryptoChallengeDecrypt(ChallengeMode.CBC, settingsCookie).get("name"));

        return "crypto/detail";
    }


    @RequestMapping(value = "/", method = RequestMethod.POST)
    public String cbcChallengeSetCookie(@RequestParam("name") String name, HttpServletResponse response) throws IOException, GeneralSecurityException, JSONException {

        JSONObject json = new JSONObject();
        json.put("name", name);
        json.put("token", TOKEN);
        JSONObject crypto = new JSONObject();
        crypto.put("algorithm", "aes-128-cbc");
        crypto.put("iv", CRYPTO_IV);
        crypto.put("key", CRYPTO_KEY);
        json.put("crypto", crypto);

        Cookie cookie = new Cookie("settings", cryptoChallengeEncrypt(ChallengeMode.CBC, json.toString()));
        response.addCookie(cookie);

        return "redirect:/";
    }
}
